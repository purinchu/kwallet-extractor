#!/usr/bin/env python

# /// script
# requires-python = ">=3.12"
# dependencies = []
# ///

from typing import Any, TypeAlias
import argparse
import sys
import xml.etree.ElementTree as ET

EntryDict: TypeAlias = dict[str, str]

# "uv tool run mypy --strict kwallet-extractor" for type checking
def main() -> None:
    # parse cmdline args
    parser = argparse.ArgumentParser(
            description='Extracts passwords and credentials from KWallet XML files'
            )
    parser.add_argument('-a', '--all-fields', action='store_true',
                        help='Extract from all KWallet folders, not just "Passwords"')
    parser.add_argument('--show-chrome-form-data', action='store_true',
                        help='Also output Google Chrome form data if present')
    parser.add_argument('input',
                        help='Path to XML export to read')

    args = parser.parse_args()

    try:
        root = parse_xml(args.input)

        out: EntryDict = dict()

        for folder in root:
            if folder.tag != 'folder':
                raise Exception(f"Encountered invalid folder tag <{folder.tag}>")

            folder_name = folder.attrib.get('name', '')
            num_children = len(folder)

            # Ignore Chrome data by default as it is in custom binary format
            if folder_name.startswith("Chrome Form Data") and not args.show_chrome_form_data:
                continue

            print(f"Handling folder {folder_name} with {num_children} items", file=sys.stderr)

            for entry in folder:
                entry_name = entry.attrib.get('name') or ''
                key = '/'.join([folder_name, entry_name])
                child_entries: EntryDict = dict()

                if len(entry) == 0: # No children
                    if entry.tag == 'password': # 99.9% of time
                        child_entries = extract_pw_entry(entry, key)
                    else:
                        # But a <stream> is also possible, and unhandled
                        print(f"Ignoring <{entry.tag}> data under {folder_name}/{entry_name}", file=sys.stderr)
                else:
                    child_entries = extract_map_entries(entry, key)

                out = merge_entries(out, child_entries)

        print(f"Recorded {len(out.keys())} credential entries for output", file=sys.stderr)
        serialize(out)

    except Exception as e:
        # Some kind of error encountered
        print(f"Ran into an error while reading {args.input}:\n{e}")
        sys.exit(1)

def merge_entries(parent: EntryDict, children: EntryDict) -> EntryDict:
    out = parent

    for key in children:
        if key in out and out[key] != children[key]:
            raise Exception(f"Value for {key} would be overwritten by a different value!")

    out |= children
    return out

def extract_pw_entry(pw_elem: ET.Element, base_key: str) -> EntryDict:
    if pw_elem.tag != 'password':
        raise Exception(f"Encountered <{pw_elem.tag}> when <password> expected!")

    value = pw_elem.text or ''
    map_entries = { base_key: value }

    return map_entries

def extract_map_entries(map_elem: ET.Element, base_key: str) -> EntryDict:
    map_entries = dict()

    for child_entry in map_elem:
        if child_entry.tag != 'mapentry':
            raise Exception(f"Encountered <{child_entry.tag}> when <mapentry> expected!")

        child_entry_name = child_entry.attrib.get('name')
        child_entry_value = child_entry.text or ''

        # This can happen on old XML exports dating back to KDE 3 times, apparently. For some of my
        # Bugzilla passwords there will be a <mapentry name="">password</mapentry> with two more
        # 'normal' map entries with the actual username/password.
        if child_entry_name is None or len(child_entry_name) < 1:
            print (f"Ignoring mapentry for {base_key} with an empty name", file=sys.stderr)
            continue

        # Likewise there can be empty form data values for things like address fields left blank.
        # We can just skip these without a warning
        if len(child_entry_value) < 1:
            continue

        key = '/'.join([base_key, child_entry_name])
        map_entries[key] = child_entry_value

    return map_entries

def serialize(entries: EntryDict) -> None:
    for name, pw in sorted(entries.items()):
        print (f'{name},"{pw}"')

def parse_xml(filename: str) -> ET.Element:
    tree = ET.parse(filename)
    root = tree.getroot()

    if root.tag != "wallet":
        raise Exception(f"The wallet XML had the wrong root element! Expected <wallet>, got <{root.tag}>")

    return root

if __name__ == "__main__":
    main()
