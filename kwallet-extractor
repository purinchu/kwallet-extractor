#!/usr/bin/env python

# /// script
# requires-python = ">=3.12"
# dependencies = []
# ///

from typing import Any, TypeAlias

import argparse
import csv
import json
import sys
import xml.etree.ElementTree as ET

EntryDict: TypeAlias = dict[str, dict[str, str]]

# global to disambiguate credential entries
g_key_id: int = 0
g_seen_set: set[str] = set()

# "uv tool run mypy --strict kwallet-extractor" for type checking
def main() -> None:
    # parse cmdline args
    parser = argparse.ArgumentParser(
            description='Extracts passwords and credentials from KWallet XML files'
            )
#   parser.add_argument('-a', '--all-fields', action='store_true',
#                       help='Extract from all KWallet folders, not just "Passwords"')
    parser.add_argument('-x', '--ignore', action='append',
                        choices=['no_username', 'no_password', 'newline_in_pw', 'no_website', 'no_issues_noted'],
                        help='Allows for ignoring entries with known issues in the output (can use multiple times)')
    parser.add_argument('--show-chrome-form-data', action='store_true',
                        help='Also output Google Chrome form data if present')
    parser.add_argument('-v', '--version', action='version', version='%(prog)s 0.1',
                        help='Show version output and exit')
    parser.add_argument('input',
                        help='Path to XML export to read')

    args = parser.parse_args()

    try:
        root = parse_xml(args.input)

        out: EntryDict = dict()

        for folder in root:
            if folder.tag != 'folder':
                raise Exception(f"Encountered invalid folder tag <{folder.tag}>")

            folder_name = folder.attrib.get('name', '')
            num_children = len(folder)

            # Ignore Chrome data by default as it is in custom binary format
            if folder_name.startswith("Chrome Form Data") and not args.show_chrome_form_data:
                continue

            print(f"Handling folder {folder_name} with {num_children} items", file=sys.stderr)

            for entry in folder:
                entry_name = entry.attrib.get('name') or ''
                child_entries: EntryDict = dict()

                if len(entry) == 0: # No children
                    if entry.tag == 'password': # 99.9% of time
                        child_entries = extract_pw_entry(entry, folder_name, entry_name)
                    else:
                        # But a <stream> is also possible, and unhandled
                        print(f"Ignoring <{entry.tag}> data under {folder_name}/{entry_name}", file=sys.stderr)
                else:
                    child_entries = extract_map_entries(entry, folder_name, entry_name)

                out = merge_entries(out, child_entries)

        print(f"Recorded {len(out.keys())} credential entries for output", file=sys.stderr)
        serialize(out, args.ignore)

    except Exception as e:
        # Some kind of error encountered
        print(f"Ran into an error while reading {args.input}:\n{e}", file=sys.stderr)
        sys.exit(1)

def merge_entries(parent: EntryDict, children: EntryDict) -> EntryDict:
    out = parent
    global g_key_id

    # used so we don't go crazy for when the 2nd and later dupes are all
    # different from first one seen
    global g_seen_set

    for key in children:
        renamed_key = key # name to use in `out`, which may be different

        if key in out:
            # See if there are difference in value and if so, rename one.  But
            # only do this if the values are actually different, otherwise
            # duplicate entries in the original XML will be re-duplicated in
            # the output.
            base_subval  = json.dumps(out[key],      sort_keys=True)
            child_subval = json.dumps(children[key], sort_keys=True)
            set_key = '/'.join([key, base_subval])

            if base_subval != child_subval and (not set_key in g_seen_set):
                while renamed_key in out:
                    g_key_id += 1
                    renamed_key = '/'.join([key, str(g_key_id)])

            g_seen_set.add(set_key)

        out[renamed_key] = children[key]

    return out

def extract_pw_entry(pw_elem: ET.Element, folder_name: str, entry_name: str) -> EntryDict:
    if pw_elem.tag != 'password':
        raise Exception(f"Encountered <{pw_elem.tag}> when <password> expected!")

    value = pw_elem.text or ''
    map_entries = {
        'folder': folder_name,
        'type': 'password',
        'username': '',
        'website': '',
        'other': entry_name,
        'password': value,
        }

    return {entry_name: map_entries}

def extract_map_entries(map_elem: ET.Element, folder_name: str, entry_name: str) -> EntryDict:
    map_entries = dict()

    map_entries = {
        'folder': folder_name,
        'type': 'map',
        'username': '',
        'website': entry_name, # most <map> sequences have the website in the name field
        'other': '',
        'password': '',
        }

    for child_entry in map_elem:
        if child_entry.tag != 'mapentry':
            raise Exception(f"Encountered <{child_entry.tag}> when <mapentry> expected!")

        child_entry_name = child_entry.attrib.get('name')
        child_entry_value = child_entry.text or ''

        # This can happen on old XML exports dating back to KDE 3 times, apparently. For some of my
        # Bugzilla passwords there will be a <mapentry name="">password</mapentry> with two more
        # 'normal' map entries with the actual username/password.
        if child_entry_name is None or len(child_entry_name) < 1:
            print (f"Ignoring mapentry for {folder_name}/{entry_name} with an empty name", file=sys.stderr)
            continue

        # Likewise there can be empty form data values for things like address fields left blank.
        # We can just skip these without a warning
        if len(child_entry_value) < 1:
            continue

        map_key = 'other'
        if 'pass' in child_entry_name:
            map_key = 'password'
        elif 'user' in child_entry_name or 'login' in child_entry_name:
            map_key = 'username'

        map_entries[map_key] = child_entry_value

    return {entry_name: map_entries}

def serialize(entries: EntryDict, filtered_issues: list[str]) -> None:
    fieldnames = ['folder', 'type', 'issues','username', 'website', 'other', 'password']
    writer = csv.DictWriter(sys.stdout, dialect='unix', quoting=csv.QUOTE_MINIMAL, fieldnames=fieldnames)

    # Any entries with a matching issue to this set should be filtered out
    filter_set = set(filtered_issues)

    writer.writeheader()
    for name in sorted(entries):
        entry = entries[name]
        issues = list()

        if len(entry['username']) == 0:
            issues.append('no_username')
        if len(entry['password']) == 0:
            issues.append('no_password')
        if "\n" in entry['password']:
            issues.append('newline_in_pw')
        if len(entry['website']) == 0:
            issues.append('no_website')
        if len(issues) == 0:
            issues.append('no_issues_noted')

        if len(filter_set.intersection(issues)) > 0:
            continue

        entry['issues'] = ';'.join(issues)

        writer.writerow(entries[name])

def parse_xml(filename: str) -> ET.Element:
    tree = ET.parse(filename)
    root = tree.getroot()

    if root.tag != "wallet":
        raise Exception(f"The wallet XML had the wrong root element! Expected <wallet>, got <{root.tag}>")

    return root

if __name__ == "__main__":
    main()
